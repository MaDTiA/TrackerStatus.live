import sys
import socket
import urllib.request
import urllib.parse
from urllib.parse import urlparse
from concurrent.futures import ThreadPoolExecutor, as_completed
import struct
import random
import os
import re

def parse_tracker_line(line):
    """Extract clean tracker URL from various formats"""
    line = line.strip()
    # Remove markdown link format [url](url) or [text](url)
    if line.startswith('[') and '](' in line and line.endswith(')'):
        line = line.split('](')[1].rstrip(')')
    return line

def bdecode_simple(data):
    """Simple bencode decoder for tracker responses"""
    try:
        if not data:
            return None
        # Check if it starts with 'd' (dictionary) which is valid bencoded response
        if data[0:1] == b'd':
            # Look for common tracker response keys
            if b'interval' in data or b'peers' in data or b'failure reason' in data:
                return True
        return False
    except:
        return False

def is_parked_or_expired_domain(content, url):
    """Detect parked domains, expired domains, or advertising pages"""
    if not content:
        return False
    
    try:
        content_lower = content.decode('utf-8', errors='ignore').lower()
    except:
        content_lower = str(content).lower()
    
    # Common indicators of parked/expired domains
    parked_indicators = [
        'domain for sale',
        'domain is for sale',
        'buy this domain',
        'domain expired',
        'domain has expired',
        'this domain is expired',
        'register this domain',
        'domain available',
        'parked domain',
        'domain parking',
        'coming soon',
        'under construction',
        'page not found',
        '404 not found',
        'namecheap',
        'godaddy parked',
        'sedo domain parking',
        'domain portfolio',
        'premium domain',
        'afternic',
        'escrow.com',
        'dan.com/buy-domain',
        'undeveloped',
        'this webpage was generated by the domain owner',
        'hugedomains.com',
        'bodis.com',
        'sedoparking',
    ]
    
    # Check for advertising/parking indicators
    for indicator in parked_indicators:
        if indicator in content_lower:
            return True
    
    # Check if response is HTML (trackers return bencoded data, not HTML)
    if b'<html' in content[:500].lower() or b'<!doctype html' in content[:500].lower():
        return True
    
    return False

def check_http_tracker(url, timeout=10):
    """Check HTTP/HTTPS tracker with proper BitTorrent protocol validation"""
    try:
        # Construct a minimal announce request
        params = {
            'info_hash': b'\x00' * 20,
            'peer_id': b'-PY0001-' + bytes(random.randint(0, 255) for _ in range(12)),
            'port': 6881,
            'uploaded': 0,
            'downloaded': 0,
            'left': 0,
            'compact': 1,
            'event': 'started'
        }
        
        query_string = urllib.parse.urlencode(params, doseq=True)
        test_url = f"{url}?{query_string}"
        
        req = urllib.request.Request(test_url, headers={'User-Agent': 'Python-Tracker-Checker/1.0'})
        
        with urllib.request.urlopen(req, timeout=timeout) as response:
            status_code = response.getcode()
            content = response.read()
            
            # Check for parked/expired domain first
            if is_parked_or_expired_domain(content, url):
                return 'invalid', 'parked/expired domain or advertising page'
            
            # Validate BitTorrent bencoded response
            if bdecode_simple(content):
                # Check if it's a valid tracker response or failure message
                if b'failure reason' in content:
                    # Tracker is alive but returned an error (still a valid tracker)
                    return 'alive', 'valid tracker (returned failure reason)'
                elif b'interval' in content or b'peers' in content:
                    return 'alive', 'valid tracker response'
                else:
                    return 'alive', 'valid bencoded response'
            
            # Check for common false positives
            if status_code == 200:
                # If response is HTML, it's not a tracker
                if b'<html' in content[:100].lower():
                    return 'invalid', 'returns HTML page (not a tracker)'
                # If it's too long to be a tracker response, probably not a tracker
                if len(content) > 50000:
                    return 'invalid', 'response too large (likely not a tracker)'
                # If response contains typical web content
                if b'<body' in content.lower() or b'<head' in content.lower():
                    return 'invalid', 'returns web page (not a tracker)'
                
                return 'dead', f'HTTP {status_code} but invalid tracker response'
            elif 200 <= status_code < 400:
                return 'dead', f'HTTP {status_code} (no valid tracker data)'
            else:
                return 'dead', f'HTTP {status_code}'
                
    except urllib.error.HTTPError as e:
        # Some trackers return 400/403 for invalid requests but are still alive
        if e.code in [400, 403]:
            try:
                content = e.read()
                # Check if error response is bencoded (valid tracker error)
                if bdecode_simple(content):
                    return 'alive', f'HTTP {e.code} (valid tracker, invalid request)'
            except:
                pass
        return 'dead', f'HTTP error {e.code}'
    except urllib.error.URLError as e:
        return 'dead', f'connection failed: {str(e.reason)[:50]}'
    except socket.timeout:
        return 'dead', 'timeout'
    except Exception as e:
        return 'dead', f'error: {str(e)[:50]}'

def check_udp_tracker(url, timeout=10):
    """Check UDP tracker availability using BitTorrent protocol"""
    try:
        parsed = urlparse(url)
        host = parsed.hostname
        port = parsed.port or 80
        
        # Resolve hostname
        ip = socket.gethostbyname(host)
        
        # Create UDP socket
        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        sock.settimeout(timeout)
        
        # BitTorrent UDP tracker connect request
        connection_id = 0x41727101980  # Protocol magic constant
        action = 0  # Connect
        transaction_id = random.randint(0, 2**32 - 1)
        
        # Pack connect request
        request = struct.pack('!QII', connection_id, action, transaction_id)
        
        sock.sendto(request, (ip, port))
        
        # Wait for response
        try:
            response, addr = sock.recvfrom(16)
            if len(response) >= 16:
                recv_action, recv_trans_id = struct.unpack('!II', response[:8])
                if recv_trans_id == transaction_id and recv_action == 0:
                    sock.close()
                    return 'alive', 'valid UDP tracker response'
            sock.close()
            return 'alive', 'responded (partial)'
        except socket.timeout:
            sock.close()
            return 'dead', 'no response'
            
    except socket.gaierror:
        return 'invalid', 'DNS resolution failed'
    except Exception as e:
        return 'dead', f'error: {str(e)[:50]}'

def validate_tracker(tracker_url):
    """Main validation function"""
    try:
        parsed = urlparse(tracker_url)
        protocol = parsed.scheme.lower()
        
        if not protocol:
            return 'invalid', 'missing protocol', 'unknown'
        
        if not parsed.hostname:
            return 'invalid', 'invalid URL format', protocol
        
        if protocol in ['http', 'https']:
            status, reason = check_http_tracker(tracker_url)
            return status, reason, protocol
        elif protocol == 'udp':
            status, reason = check_udp_tracker(tracker_url)
            return status, reason, protocol
        else:
            return 'invalid', f'unsupported protocol: {protocol}', protocol
            
    except Exception as e:
        return 'invalid', f'parse error: {str(e)[:50]}', 'unknown'

def main(input_file, output_file, max_workers=20):
    """Main script function"""
    print(f"Reading trackers from {input_file}...")
    
    # Read and parse trackers
    trackers = []
    try:
        with open(input_file, 'r', encoding='utf-8', errors='ignore') as f:
            for line in f:
                clean_line = parse_tracker_line(line)
                if clean_line and not clean_line.startswith('#'):
                    trackers.append(clean_line)
    except FileNotFoundError:
        print(f"Error: {input_file} not found!")
        print(f"Please create {input_file} in the same folder as this script.")
        return
    
    if not trackers:
        print(f"Error: No trackers found in {input_file}")
        return
    
    print(f"Checking {len(trackers)} trackers with STRICT validation...")
    print("(Validating BitTorrent protocol responses, detecting parked domains)\n")
    
    # Results storage
    results = {
        'alive': [],
        'dead': [],
        'invalid': []
    }
    
    # Parallel checking
    with ThreadPoolExecutor(max_workers=max_workers) as executor:
        future_to_tracker = {executor.submit(validate_tracker, t): t for t in trackers}
        
        completed = 0
        for future in as_completed(future_to_tracker):
            tracker = future_to_tracker[future]
            status, reason, protocol = future.result()
            
            results[status].append({
                'url': tracker,
                'protocol': protocol,
                'reason': reason
            })
            
            completed += 1
            if completed % 10 == 0:
                print(f"Progress: {completed}/{len(trackers)}")
    
    # Write results
    print(f"\nWriting results to {output_file}...")
    with open(output_file, 'w', encoding='utf-8') as out:
        # Summary
        out.write("=" * 70 + "\n")
        out.write("TRACKER VALIDATION RESULTS (STRICT MODE)\n")
        out.write("=" * 70 + "\n")
        out.write(f"Total Checked: {len(trackers)}\n")
        out.write(f"Alive (Valid): {len(results['alive'])}\n")
        out.write(f"Dead: {len(results['dead'])}\n")
        out.write(f"Invalid (Parked/Expired/Not Trackers): {len(results['invalid'])}\n")
        out.write("=" * 70 + "\n\n")
        
        # Group by status and protocol
        for status in ['alive', 'dead', 'invalid']:
            items = results[status]
            if not items:
                continue
            
            # Group by protocol
            protocols = {}
            for item in items:
                proto = item['protocol']
                if proto not in protocols:
                    protocols[proto] = []
                protocols[proto].append(item)
            
            out.write(f"\n{'#' * 70}\n")
            out.write(f"# {status.upper()} TRACKERS ({len(items)} total)\n")
            out.write(f"{'#' * 70}\n\n")
            
            for proto in sorted(protocols.keys()):
                proto_items = protocols[proto]
                out.write(f"--- {proto.upper()} ({len(proto_items)}) ---\n")
                for item in proto_items:
                    out.write(f"{item['url']}\n")
                    if status != 'alive':  # Show reason for dead/invalid
                        out.write(f"  └─ Reason: {item['reason']}\n")
                out.write("\n")
    
    print(f"\nDone! Results saved to {output_file}")
    print(f"✓ Alive (Valid Trackers): {len(results['alive'])}")
    print(f"✗ Dead: {len(results['dead'])}")
    print(f"⚠ Invalid (Parked/Expired/Not Trackers): {len(results['invalid'])}")

if __name__ == '__main__':
    # Change to script directory
    if getattr(sys, 'frozen', False):
        script_dir = os.path.dirname(sys.executable)
    else:
        script_dir = os.path.dirname(os.path.abspath(__file__))
    
    os.chdir(script_dir)
    
    # Check for command line arguments or use defaults
    if len(sys.argv) < 2:
        input_path = 'trackers.txt'
        output_path = 'filtered.txt'
        print("=" * 70)
        print("TRACKER CHECKER - STRICT VALIDATION MODE")
        print("=" * 70)
        print(f"Input file: {input_path}")
        print(f"Output file: {output_path}")
        print("=" * 70 + "\n")
    else:
        input_path = sys.argv[1]
        output_path = sys.argv[2] if len(sys.argv) > 2 else 'filtered.txt'
    
    try:
        main(input_path, output_path)
    except Exception as e:
        print(f"\n❌ Error: {e}")
        import traceback
        traceback.print_exc()
    
    print("\n" + "=" * 70)
    input("Press Enter to exit...")
